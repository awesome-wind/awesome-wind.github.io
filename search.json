[{"title":"MediaSDK编码","url":"//blog/2022/03/mediasdk-encoder.html","content":"<blockquote>\n<p>前置条件：下载并安装好<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaW50ZWwuY29tL2NvbnRlbnQvd3d3L3VzL2VuL2RldmVsb3Blci90b29scy9tZWRpYS1zZGsvY2hvb3NlLWRvd25sb2FkLWNsaWVudC5odG1s\">media sdk工程<i class=\"fa fa-external-link-alt\"></i></span></p>\n</blockquote>\n<p>使用visual studio打开默认的工程sample_encode.sln后，在vs中可以看到整个工程的代码结构。程序的启动点位于sample_encode.cpp中的main函数，包含了编码器创建，编码过程以及销毁流程。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"main函数结构\"><a href=\"#main函数结构\" class=\"headerlink\" title=\"main函数结构\"></a>main函数结构</h2><p>查看代码逻辑，整体代码流程可分为以下五个部分</p>\n<p><strong>解析外部传参</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Parsing Input Stream working with presets</span></span><br><span class=\"line\">sts = <span class=\"built_in\">ParseInputString</span>(argv, (mfxU8)argc, &amp;Params);</span><br><span class=\"line\"><span class=\"built_in\">ModifyParamUsingPresets</span>(Params);</span><br></pre></td></tr></table></figure>\n\n<p><strong>创建Pipeline</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">pPipeline.<span class=\"built_in\">reset</span>(<span class=\"built_in\">CreatePipeline</span>(Params));</span><br><span class=\"line\">sts = pPipeline-&gt;<span class=\"built_in\">Init</span>(&amp;Params);</span><br><span class=\"line\"><span class=\"comment\">// print current kind of pipeline info</span></span><br><span class=\"line\">pPipeline-&gt;<span class=\"built_in\">PrintInfo</span>(); </span><br></pre></td></tr></table></figure>\n\n<p><strong>摄像头操作</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// using yuv file as input generally,</span></span><br><span class=\"line\">pPipeline-&gt;<span class=\"built_in\">CaptureStartV4L2Pipeline</span>();</span><br><span class=\"line\">pPipeline-&gt;<span class=\"built_in\">CaptureStopV4L2Pipeline</span>();</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>if camera is wanted, macro ENABLE_V4L2_SUPPORT should be added to project</p>\n</blockquote>\n<p><strong>编码过程</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">sts = pPipeline-&gt;<span class=\"built_in\">Run</span>();</span><br><span class=\"line\"><span class=\"keyword\">if</span>(sts  == MX_ERR_DEVICE_LOST || sts == MFX_ERR_DEVICE_FAILED)&#123;</span><br><span class=\"line\">    sts = pPipeline-&gt;<span class=\"built_in\">ResetDevice</span>();</span><br><span class=\"line\">    sts = pPipeline-&gt;<span class=\"built_in\">ResetMFXComponents</span>(&amp;Params);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>销毁逻辑</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">pPipeline-&gt;<span class=\"built_in\">Close</span>();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"传参解析\"><a href=\"#传参解析\" class=\"headerlink\" title=\"传参解析\"></a>传参解析</h2><p>外部传递参数存在可选与必选参数，</p>\n<h4 id=\"必选参数\"><a href=\"#必选参数\" class=\"headerlink\" title=\"必选参数\"></a>必选参数</h4><table>\n<thead>\n<tr>\n<th>编码标准</th>\n<th>输入文件</th>\n<th>输出文件</th>\n<th>宽</th>\n<th>高</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>h264&#x2F;h265&#x2F;jepg</td>\n<td>-i xxx.yuv</td>\n<td>-o xxx.bitstream</td>\n<td>-w xxx</td>\n<td>-h xxx</td>\n</tr>\n</tbody></table>\n<p><code>e.g. sample_encode.exe h264 -i input.yuv -o output.h264 –w 720 –h 480</code></p>\n<h4 id=\"可选参数\"><a href=\"#可选参数\" class=\"headerlink\" title=\"可选参数\"></a>可选参数</h4><table>\n<thead>\n<tr>\n<th>编码实现</th>\n<th>编码格式</th>\n<th>码控方式</th>\n<th>会议模式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-sw&#x2F;-hw</td>\n<td>-yuy2&#x2F;-nv12&#x2F;-rgb4</td>\n<td>-vbr&#x2F;-cbr&#x2F;-qvbr&#x2F;-avbr&#x2F;-cqp</td>\n<td>-vcm</td>\n</tr>\n<tr>\n<td>I帧间隔</td>\n<td>参考帧数</td>\n<td>HEVC P帧参考帧数</td>\n<td>svc 设置</td>\n</tr>\n<tr>\n<td>-idr_internal</td>\n<td>-x numRef</td>\n<td>-num_active_P numRef</td>\n<td>-AvcTemporalLayers &quot;1 2 4 0 0 0 0 0&quot;</td>\n</tr>\n<tr>\n<td>slice 数量</td>\n<td>GOP size</td>\n<td>B帧</td>\n<td>其他常用</td>\n</tr>\n<tr>\n<td>-num_slice</td>\n<td>-g size</td>\n<td>-bref&#x2F;-nobref(default)</td>\n<td>-f&#x2F;-b&#x2F;-u&#x2F;-q</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>HEVC中参考帧数与svc设置是互斥的，直接会导致编码器初始化失败.参数设置详见readme-encode_windows.pdf</p>\n</blockquote>\n<h4 id=\"解析过程\"><a href=\"#解析过程\" class=\"headerlink\" title=\"解析过程\"></a>解析过程</h4><p>默认设置使用硬编，无camera，参考帧数量为0，I420格式，而后通过匹配外部传入参数对pParams进行赋值,e.g.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"number\">0</span> == <span class=\"built_in\">msdk_strcmp</span>(strInput[i],<span class=\"built_in\">MSDK_STRING</span>(<span class=\"string\">&quot;-sw&quot;</span>))&#123;</span><br><span class=\"line\">    pParams-&gt;bUseHWLib = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"创建pipeline\"><a href=\"#创建pipeline\" class=\"headerlink\" title=\"创建pipeline\"></a>创建pipeline</h1><h4 id=\"pipeline-reset\"><a href=\"#pipeline-reset\" class=\"headerlink\" title=\"pipeline reset\"></a>pipeline reset</h4><p>mediaSDK提供了三种pipeline模式</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">CRegionEncodingPipeline : 区域编码模式，不支持硬编</span><br><span class=\"line\">CUserPipeline：自定义编码pipeline，可设入插件，进行图像处理，demo给出的为旋转图像能力</span><br><span class=\"line\">CEncodingPipeline：普通编码模式</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"pipeline-init\"><a href=\"#pipeline-init\" class=\"headerlink\" title=\"pipeline init\"></a>pipeline init</h4><ol>\n<li><p>依据参数与限制条件，选择最合适的硬件&#x2F;软件实现</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">mfxInitParamlWrap initPar;</span><br><span class=\"line\">initPar.Version.Major = <span class=\"number\">1</span>;</span><br><span class=\"line\">initPar.Version.Minor = <span class=\"number\">0</span>;</span><br><span class=\"line\">initPar.GPUCopy = nParams-&gt;gpuCopy;</span><br><span class=\"line\">mfxStatus sts = <span class=\"built_in\">GetImpl</span>(*pParams,initPar.Implementation);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用获取到的编码器去初始化mfxsession</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">sts = m_mfxSession.<span class=\"built_in\">InitEx</span>(initPar);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>获取系统版本，检验特性支持的api版本，满足时加载编码器<br>如果有自定义的编码器，则加载自定义的,若没有指定编码器的path或者guid则检查mediasdk当前版本是否默认含有上述选择出的编解码器，有则加载，否则判断为不支持</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">mfxVersion version;</span><br><span class=\"line\">sts = <span class=\"built_in\">MFXQueryVersion</span>(m_mfxSession,&amp;version);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// do some check by version</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (pParams-&gt;pluginParams.type == MFX_PLUGINLOAD_TYPE_FILE &amp;&amp; <span class=\"built_in\">msdk_strnlen</span>(pParams-&gt;pluginParams.strPluginPath, <span class=\"built_in\">sizeof</span>(pParams-&gt;pluginParams.strPluginPath)))&#123;</span><br><span class=\"line\">    m_pUserModule.<span class=\"built_in\">reset</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">MFXVideoUSER</span>(m_mfxSession));</span><br><span class=\"line\">    m_pPlugin.<span class=\"built_in\">reset</span>(<span class=\"built_in\">LoadPlugin</span>(MFX_PLUGINTYPE_VIDEO_ENCODE, m_mfxSession, pParams-&gt;pluginParams.pluginGuid, <span class=\"number\">1</span>, pParams-&gt;pluginParams.strPluginPath, (mfxU32)<span class=\"built_in\">msdk_strnlen</span>(pParams-&gt;pluginParams.strPluginPath, <span class=\"built_in\">sizeof</span>(pParams-&gt;pluginParams.strPluginPath))));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m_pPlugin.<span class=\"built_in\">get</span>() == <span class=\"literal\">NULL</span>) sts = MFX_ERR_UNSUPPORTED;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">bool</span> isDefaultPlugin = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">AreGuidsEqual</span>(pParams-&gt;pluginParams.pluginGuid, MSDK_PLUGINGUID_NULL)) &#123;</span><br><span class=\"line\">        mfxIMPL impl = pParams-&gt;bUseHWLib ? MFX_IMPL_HARDWARE : MFX_IMPL_SOFTWARE;</span><br><span class=\"line\">        pParams-&gt;pluginParams.pluginGuid = <span class=\"built_in\">msdkGetPluginUID</span>(impl, MSDK_VENCODE, pParams-&gt;CodecId);</span><br><span class=\"line\">        isDefaultPlugin = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">AreGuidsEqual</span>(pParams-&gt;pluginParams.pluginGuid, MSDK_PLUGINGUID_NULL)) &#123;</span><br><span class=\"line\">        m_pPlugin.<span class=\"built_in\">reset</span>(<span class=\"built_in\">LoadPlugin</span>(MFX_PLUGINTYPE_VIDEO_ENCODE, m_mfxSession, pParams-&gt;pluginParams.pluginGuid, <span class=\"number\">1</span>));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m_pPlugin.<span class=\"built_in\">get</span>() == <span class=\"literal\">NULL</span>) sts = MFX_ERR_UNSUPPORTED;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建编码器与初始化</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">m_pmfxENC = <span class=\"keyword\">new</span> <span class=\"built_in\">MFXVideoENCODE</span>(m_mfxSession); <span class=\"comment\">// create encoder</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// if no camera, file input system is inited.</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(!isV4L2InputEnable)&#123;</span><br><span class=\"line\">    sts = m_FileReader.<span class=\"built_in\">Init</span>(pParams-&gt;InputFiles, nParams-&gt;FileInputFourCC, readerShift);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sts = <span class=\"built_in\">InitFileWriters</span>(pParams); <span class=\"comment\">// init output file</span></span><br><span class=\"line\"></span><br><span class=\"line\">sts = <span class=\"built_in\">CretaeAlloctor</span>();  <span class=\"comment\">// memory init used by encoding</span></span><br><span class=\"line\">sts = <span class=\"built_in\">InitMfxEncParams</span>(pParams); <span class=\"comment\">// collect all kinds of encoder params </span></span><br><span class=\"line\">sts = <span class=\"built_in\">InitMfxVppParams</span>(pParams); <span class=\"comment\">// init vpp if needed</span></span><br><span class=\"line\">sts = <span class=\"built_in\">ResetMFXComponents</span>(pParams); <span class=\"comment\">// init task pool and set params into encoder</span></span><br><span class=\"line\"><span class=\"built_in\">InitV4L2Pipeline</span>(pParams); <span class=\"comment\">// init camera if V4L2 is opened</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h1 id=\"encode\"><a href=\"#encode\" class=\"headerlink\" title=\"encode\"></a>encode</h1><p>创建for循环，循环进行以下流程的处理</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">读帧：<span class=\"built_in\">LoadNextFrame</span>(mfxFrameSurface1)</span><br><span class=\"line\">编码：m_mfxENC-&gt;<span class=\"built_in\">EncodeFrameAsync</span>(mfxEncodeCtrl,mfxFrameSurface1,&amp;mfxBitstreamWrapper,&amp;mfxSyncPoint)</span><br><span class=\"line\">写流：<span class=\"built_in\">WriteNextFrame</span>(&amp;mfxBitstream，<span class=\"type\">bool</span>)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ExtendSurface创建\"><a href=\"#ExtendSurface创建\" class=\"headerlink\" title=\"ExtendSurface创建\"></a>ExtendSurface创建</h4><p>extendSurface包含了编码器的数据信息与控制信息，从文件中的读取的帧会按照特定格式存放于ExtendSurface.pSurface中，ExtendSurface.pCtrl则带有帧信息，有一定的控制作用，例如编I帧等</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ExtendSurface</span> &#123;</span><br><span class=\"line\">    mfxFrameSurface1 *pSurface;  <span class=\"comment\">// 输入编码器的帧数据</span></span><br><span class=\"line\">    mfxEncodeCtrl    *pCtrl;  <span class=\"comment\">// 编码器控制参数</span></span><br><span class=\"line\">    mfxSyncPoint      Syncp;  <span class=\"comment\">//同步时机</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ExtendedSurface encSurface,preencSurface,vppSurface = &#123;&#125;;</span><br><span class=\"line\">m_nEncSurfIdx = <span class=\"built_in\">GetFreeSurface</span>(m_pEncSurfaces, m_EncResponse.NumFrameActual);</span><br><span class=\"line\">preencSurface.pSurface = vppSurface.pSurface = &amp;m_pEncSurfaces[m_nEncSurfIdx];</span><br></pre></td></tr></table></figure>\n<h4 id=\"sTask创建\"><a href=\"#sTask创建\" class=\"headerlink\" title=\"sTask创建\"></a>sTask创建</h4><p>sTask会创建任务池，承担两项任务职能</p>\n<ul>\n<li>取得编码后的码流数据</li>\n<li>将码流数据写入文件</li>\n</ul>\n<p>每次需要执行代码时，便获取当前的空任务，获取时会将当前的任务队列中的码流写文件任务执行，编码完成后会将编码后的数据填入<code>pCurrentTask.mfxBS</code>中。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">sts = <span class=\"built_in\">GetFreeTask</span>(&amp;pCurrentTask);</span><br><span class=\"line\">    <span class=\"built_in\">WriteNextFrame</span>(mfxBitstream,<span class=\"type\">bool</span>) <span class=\"function\">in <span class=\"title\">GetFreeTask</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">EncodeOneFrame</span><span class=\"params\">(encSurface, pCurrentTask)</span></span>;</span><br></pre></td></tr></table></figure>","categories":["Codec"],"tags":["MediaSDK","QSV","Encoder"]},{"title":"SVC介绍","url":"//blog/2022/04/mediasdk-svc.html","content":"<p>SVC(Scaled Video Coding)最早作为H.264标准的一个扩展最初由JVT在2004年开始制定，并于2007年7月获得ITU批准，HEVC现均已支持SVC。H.264 SVC以H.264 AVC视频编解码器标准为基础，利用了AVC编解码器的各种高效算法工具，在编码产生的编码视频时间上（帧率）、空间上（分辨率）可扩展，并且是在视频质量方面可扩展的，可产生不同帧速率、分辨率或质量等级的解码视频。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>SVC，可分层视频编解码，分为时域可适性（<em>Temporal Scalability</em>），空域可适性（<em>spatial Scalability</em>）和质量可适性（<em>quality Scalability</em>），是一种能将视频流分割为多个分辨率、质量和帧率层的技术，一般存在一个基本层和一个或以上的增强层，为大多数视频会议设备所采用H264&#x2F;HEVC视频编解码标准的扩展。空间可扩展性与质量可扩展性会显著增加解码器的复杂度以及显著降低编码效率，因此并未被广泛支持，然而时域可适性却可以带来显著的编码效率提升,因此而得到广泛使用。</p>\n<h4 id=\"时域可适性\"><a href=\"#时域可适性\" class=\"headerlink\" title=\"时域可适性\"></a>时域可适性</h4><p>对于混合编码模式，可使用运动补偿编码方式，使高层Layer参考低层Layer或者同层layer即可产生时域可适性。可根据网络与解码设备状况从高层layer依次丢帧至基本层，高层layer解码依赖于底层layer。</p>\n<p>4层时域结构，包含I帧与B帧，为1:1:2:4结构<br><img src=\"/images/temporal_b_frames.jpg\" alt=\"Temporal SVC\" loading=\"lazy\"></p>\n<p>3层时域结构，包含I帧与B帧，为1:2:4结构<br><img src=\"/images/temporal_nodyadic_b_frames.jpg\" alt=\"NonDyadic Temporal SVC\" loading=\"lazy\"></p>\n<p>4层IPPP低延时结构，包含I帧与P帧，为1:1:2:4结构<br><img src=\"/images/temporal_ippp_frames.jpg\" alt=\"IPPP temporal SVC\" loading=\"lazy\"></p>\n<h4 id=\"空域可适性\"><a href=\"#空域可适性\" class=\"headerlink\" title=\"空域可适性\"></a>空域可适性</h4><p>空域可扩展性的实现基于多层layer编码方式，每层对应各自的分辨率，一般低层layer分辨率较低，每帧参考于同层帧或者其依赖标识层帧（低层layer）。每层均会采用帧内预测与帧间预测，帧内预测时，高层layer参考低层layer，并使用上采样提升分辨率，同层参考时则使用帧间预测。解码时并非是高层layer解码依赖底层layer，只会使用特定layer层，因此，可结合时域与空域可适性。<br><img src=\"/images/spatial_scalability.jpg\" alt=\"spatial SVC\" loading=\"lazy\"></p>\n<h4 id=\"质量可适性\"><a href=\"#质量可适性\" class=\"headerlink\" title=\"质量可适性\"></a>质量可适性</h4><p>质量可适性是一种特殊的空域可适性，每层layer的分辨率相同且不会采用上采样。<br><img src=\"/images/quality_scalability.jpg\" alt=\"quality SVC\" loading=\"lazy\"></p>\n<h2 id=\"MediaSDK-Temporal-SVC\"><a href=\"#MediaSDK-Temporal-SVC\" class=\"headerlink\" title=\"MediaSDK Temporal SVC\"></a>MediaSDK Temporal SVC</h2><p>MediaSDK的时域SVC设置，在mfxVideoParam参数集中加入mfxExtAvcTemporalLayers，并设置BaseLayerPid与每层的帧数分布，MediaSDK最多支持8层结构。<code>typedef mfxExtAvcTemporalLayers mfxExtHEVCTemporalLayers</code>表明下述时域SVC设置同样适用与HEVC。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> MfxVideoParamsWrapper = ExtBufHolder&lt;mfxVideoParam&gt;;</span><br><span class=\"line\">MfxVideoParamsWrapper m_mfxEncParams;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">auto</span> avcTemporalLayers = m_mfxEncParams.<span class=\"built_in\">AddExtBuffer</span>&lt;mfxExtAvcTemporalLayers&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">avcTemporalLayers-&gt;BaseLayerPID = <span class=\"number\">0</span>;  <span class=\"comment\">//base layer 优先级</span></span><br><span class=\"line\">std::vector&lt;mfxU16&gt; layers&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;; <span class=\"comment\">// 分层结构，1-3层帧数比为1：1：2</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">8</span>; i++) &#123;</span><br><span class=\"line\">    avcTemporalLayers-&gt;Layer[i].Scale = layers[i];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><p><span class=\"exturl\" data-url=\"aHR0cDovL2lwLmhoaS5kZS9pbWFnZWNvbV9HMS9hc3NldHMvcGRmcy9PdmVydmlld19TVkNfSUVFRTA3LnBkZg==\">http://ip.hhi.de/imagecom_G1/assets/pdfs/Overview_SVC_IEEE07.pdf<i class=\"fa fa-external-link-alt\"></i></span></p>\n","categories":["H264","HEVC","H265"],"tags":["MediaSDK","Encoder"]},{"title":"QSV 264/265 SVC实现与TemporalId提取","url":"//blog/2022/04/msdk-svc-code.html","content":"<blockquote>\n<p>SVC相关知识请参考 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9hd2Vzb21lLXdpbmQuZ2l0aHViLmlvL2Jsb2cvMjAyMi8wNC9tZWRpYXNkay1zdmMuaHRtbA==\">SVC介绍<i class=\"fa fa-external-link-alt\"></i></span></p>\n</blockquote>\n<h2 id=\"MediaSDK-Temporal-SVC\"><a href=\"#MediaSDK-Temporal-SVC\" class=\"headerlink\" title=\"MediaSDK Temporal SVC\"></a>MediaSDK Temporal SVC</h2><p>MediaSDK的时域SVC设置，在mfxVideoParam参数集中加入mfxExtAvcTemporalLayers，并设置BaseLayerPid与每层的帧数分布，MediaSDK最多支持8层结构。<code>typedef mfxExtAvcTemporalLayers mfxExtHEVCTemporalLayers</code>表明H264时域SVC设置同样适用于HEVC。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"时域SVC实现\"><a href=\"#时域SVC实现\" class=\"headerlink\" title=\"时域SVC实现\"></a>时域SVC实现</h2><p>初始化widnows QSV编码器时，如下设置即可</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> MfxVideoParamsWrapper = ExtBufHolder&lt;mfxVideoParam&gt;;</span><br><span class=\"line\">MfxVideoParamsWrapper m_mfxEncParams;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">auto</span> avcTemporalLayers = m_mfxEncParams.<span class=\"built_in\">AddExtBuffer</span>&lt;mfxExtAvcTemporalLayers&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">avcTemporalLayers-&gt;BaseLayerPID = <span class=\"number\">0</span>;  <span class=\"comment\">//base layer 优先级</span></span><br><span class=\"line\">std::vector&lt;mfxU16&gt; layers&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;; <span class=\"comment\">// 分层结构，1-3层帧数比为1：1：2</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">8</span>; i++) &#123;</span><br><span class=\"line\">    avcTemporalLayers-&gt;Layer[i].Scale = layers[i];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"时域SVC码流解析\"><a href=\"#时域SVC码流解析\" class=\"headerlink\" title=\"时域SVC码流解析\"></a>时域SVC码流解析</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hd2Vzb21lLXdpbmQuZ2l0aHViLmlvL2Jsb2cvMjAyMi8wNC9tZWRpYXNkay1zdmMuaHRtbA==\">SVC介绍<i class=\"fa fa-external-link-alt\"></i></span> 一文中可知，SVC分层是为了使订阅端在性能或者带宽不足时丢弃单层或多层帧，保障流可解码性的基础上降低帧率，那么对于接收端（一般是服务端）是如何知道当前帧属于那一层呢？</p>\n<p>部分编码器在编出一帧码流时，会有控制信息或者接口调用方式可获得当前帧的层数信息，虽然MediaSDK也提供了temporal_id信息，但实际运行过程中，该信息一直为0，即处于不可使用状态。与intel员工沟通得知，当前仅可通过码流中的nal header获取到当前帧的temporal_id（即层数）信息，这便涉及到码流结构的解析。</p>\n<h4 id=\"nal解析\"><a href=\"#nal解析\" class=\"headerlink\" title=\"nal解析\"></a>nal解析</h4><p>对于任何一帧，编码器进行编码后，至少会将其编码出一个nal，e.g. P帧与B帧大多会被编译成一个nal，nal的header带有该slice的部分信息，剩下的则是图像残差数据，对于I帧，则可能会被编译出多个nal，含有SPS，PPS以及slice。在标准码流协议中，nal的起止均以0x00 00 01或0x00 00 00 01为界限，起点后的数据即为nal的header，携带各种描述性信息。</p>\n<p>因此，想解析信息，旧的从编码后的帧内存信息中准确截取到所有nal，假定编码后的码流存储在memory中，<code>memory-&gt;data()</code>为其首部，<code>memory-&gt;size()</code>为其大小。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//构建结构体存储Nal在memory中的起始位置与载荷大小</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">NaluIndex</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> start_offset;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> payload_offset;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> payload_size;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//memory中可能存在多个nal</span></span><br><span class=\"line\">std::vector&lt;NaluIndex&gt; nalu_indexs;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;memory-&gt;<span class=\"built_in\">size</span>();) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// nalu 以 0x00 00 01 或 0x00 00 00 01 起始</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (memory-&gt;<span class=\"built_in\">data</span>()[i+<span class=\"number\">2</span>] &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        i += <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (memory-&gt;<span class=\"built_in\">data</span>()[i] == <span class=\"number\">0</span> &amp;&amp; memory-&gt;<span class=\"built_in\">data</span>()[i+<span class=\"number\">1</span>] &amp;&amp; memory-&gt;<span class=\"built_in\">data</span>()[i+<span class=\"number\">2</span>] == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        NaluIndex nal_index = &#123;i, i+<span class=\"number\">3</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nal_index.start_offset &gt; <span class=\"number\">0</span> &amp;&amp; memory-&gt;<span class=\"built_in\">data</span>()[i<span class=\"number\">-1</span>] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            nal_index.start_offset --;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 更新上一个nal的payload size</span></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> it = nalu_indexs.<span class=\"built_in\">rbegin</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (it != nalu_indexs.<span class=\"built_in\">rend</span>())</span><br><span class=\"line\">            it-&gt;payload_size = index.start_offset - it-&gt;payload_offset;</span><br><span class=\"line\"></span><br><span class=\"line\">        nalu_indexs.<span class=\"built_in\">push_back</span>(index);</span><br><span class=\"line\"></span><br><span class=\"line\">        i += <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 更新最后一个nal的载荷大小</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> it = nalu_indexs.<span class=\"built_in\">rbegin</span>();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (it != nalu_indexs.<span class=\"built_in\">rend</span>())</span><br><span class=\"line\">    it-&gt;payload_size = memory-&gt;<span class=\"built_in\">size</span>() - it-&gt;payload_offset;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"H264-temporal-id\"><a href=\"#H264-temporal-id\" class=\"headerlink\" title=\"H264 temporal_id\"></a>H264 temporal_id</h4><p>H264的SVC编码会在任何一个I&#x2F;P帧前添加一个prefix nal，其nal type 为 14，携带svc扩展信息，层数temporal_id信息也在其中。依据标准码流协议可知，nal header的第一个字节的后5位为其nalu type，而编码帧的时域SVC层数在该nal header中的第4个字节的首3位。则其解析代码可为</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ((memory-&gt;<span class=\"built_in\">data</span>()[nalu_index.payload_offset] &amp; <span class=\"number\">0x1F</span>) == <span class=\"number\">14</span>) &#123;</span><br><span class=\"line\">    temporal_id = memory-&gt;<span class=\"built_in\">data</span>()[playload_offset + <span class=\"number\">3</span>] &gt;&gt; <span class=\"number\">5</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/svc/264_svc_1.jpg\" alt=\"nal header\" loading=\"lazy\"><img src=\"/images/svc/264_svc_2.jpg\" alt=\"svc header\" loading=\"lazy\"></p>\n<h4 id=\"H265-temproal-id\"><a href=\"#H265-temproal-id\" class=\"headerlink\" title=\"H265 temproal_id\"></a>H265 temproal_id</h4><p>HEVC的SVC编码帧层数信息与H264不同，其是直接放在每一个帧的Slice header中，而非单独编一个prefix nal。依据标准码流协议可知，hevc的时域SVC层数在slice header的第二个字节的后3为。则其解析代码可为</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">temporal_id = (memory-&gt;<span class=\"built_in\">data</span>()[payload_offset + <span class=\"number\">1</span>] &amp; <span class=\"number\">0x07</span>) - <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/svc/265_svc_1.jpg\" alt=\"svc header\" loading=\"lazy\"></p>\n<p>知道了当前帧的层数信息，处于弱网弱机时，接收端就可以选择将temporal id较高的帧丢弃而不影响码流的可解码性，降低帧率从而降低接收端性能消耗以达到降低卡顿的目的。</p>\n","categories":["H264","HEVC","H265"],"tags":["MediaSDK","QSV","Encoder","Windows"]},{"title":"404","url":"//404.html","content":"<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">██╗  ██╗ ██████╗ ██╗  ██╗    ███╗   ██╗ ██████╗ ████████╗</span><br><span class=\"line\">██║  ██║██╔═████╗██║  ██║    ████╗  ██║██╔═══██╗╚══██╔══╝</span><br><span class=\"line\">███████║██║██╔██║███████║    ██╔██╗ ██║██║   ██║   ██║</span><br><span class=\"line\">╚════██║████╔╝██║╚════██║    ██║╚██╗██║██║   ██║   ██║</span><br><span class=\"line\">     ██║╚██████╔╝     ██║    ██║ ╚████║╚██████╔╝   ██║</span><br><span class=\"line\">     ╚═╝ ╚═════╝      ╚═╝    ╚═╝  ╚═══╝ ╚═════╝    ╚═╝</span><br><span class=\"line\"></span><br><span class=\"line\">    ███████╗ ██████╗ ██╗   ██╗███╗   ██╗██████╗</span><br><span class=\"line\">    ██╔════╝██╔═══██╗██║   ██║████╗  ██║██╔══██╗</span><br><span class=\"line\">    █████╗  ██║   ██║██║   ██║██╔██╗ ██║██║  ██║</span><br><span class=\"line\">    ██╔══╝  ██║   ██║██║   ██║██║╚██╗██║██║  ██║</span><br><span class=\"line\">    ██║     ╚██████╔╝╚██████╔╝██║ ╚████║██████╔╝</span><br><span class=\"line\">    ╚═╝      ╚═════╝  ╚═════╝ ╚═╝  ╚═══╝╚═════╝</span><br></pre></td></tr></table></figure>\n"},{"title":"心诚则灵","url":"/about/index.html","content":"<h2 id=\"Find-Something-Bigger-Than-Yourself\"><a href=\"#Find-Something-Bigger-Than-Yourself\" class=\"headerlink\" title=\"Find Something Bigger Than Yourself\"></a><center>Find Something Bigger Than Yourself</center></h2>"},{"title":"类别","url":"/categories/index.html","content":""},{"title":"Plugins","url":"/plugins/index.html","content":"<h3 id=\"Hexo-Plugins\"><a href=\"#Hexo-Plugins\" class=\"headerlink\" title=\"Hexo Plugins\"></a>Hexo Plugins</h3><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL25leHQtdGhlbWUvaGV4by1nZW5lcmF0b3Itc2VhcmNoZGI=\">hexo-generator-searchdb<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL25leHQtdGhlbWUvaGV4by1maWx0ZXItZW1vamk=\">hexo-filter-emoji<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL25leHQtdGhlbWUvaGV4by1wYW5ndQ==\">hexo-pangu<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL25leHQtdGhlbWUvaGV4by1maWx0ZXItbWF0aGpheA==\">hexo-filter-mathjax<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL25leHQtdGhlbWUvaGV4by13b3JkLWNvdW50ZXI=\">hexo-word-counter<i class=\"fa fa-external-link-alt\"></i></span></li>\n</ul>\n<h3 id=\"NexT-Plugins\"><a href=\"#NexT-Plugins\" class=\"headerlink\" title=\"NexT Plugins\"></a>NexT Plugins</h3><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL25leHQtdGhlbWUvaGV4by1uZXh0LXRocmVl\">hexo-next-three<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL25leHQtdGhlbWUvaGV4by1uZXh0LWZpcmV3b3Jrcw==\">hexo-next-fireworks<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL25leHQtdGhlbWUvaGV4by1uZXh0LWV4aWY=\">hexo-next-exif<i class=\"fa fa-external-link-alt\"></i></span></li>\n</ul>\n<hr>\n<ul>\n<li>Visit the <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL25leHQtdGhlbWUvYXdlc29tZS1uZXh0\">Awesome NexT<i class=\"fa fa-external-link-alt\"></i></span> list for more plugins.</li>\n</ul>\n"},{"title":"标签","url":"/tags/index.html","content":""}]