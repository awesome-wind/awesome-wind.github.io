<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>media-sdk-encoding</title>
    <url>//blog/2022/03/media-sdk-encoding.html</url>
    <content><![CDATA[<blockquote>
<p>前置条件：下载并安装好<a href="https://www.intel.com/content/www/us/en/developer/tools/media-sdk/choose-download-client.html" target="_blank" rel="noopener">media sdk工程</a></p>
</blockquote>
<p>使用visual studio打开默认的工程sample_encode.sln后，在vs中可以看到整个工程的代码结构。程序的启动点位于sample_encode.cpp中的main函数，包含了编码器创建，编码过程以及销毁流程。</p>
<a id="more"></a>
<h2 id="main函数结构"><a href="#main函数结构" class="headerlink" title="main函数结构"></a>main函数结构</h2><p>查看代码逻辑，整体代码流程可分为以下五个部分</p>
<p><strong>解析外部传参</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Parsing Input Stream working with presets</span></span><br><span class="line">sts = ParseInputString(argv, (mfxU8)argc, &amp;Params);</span><br><span class="line">ModifyParamUsingPresets(Params);</span><br></pre></td></tr></table></figure></p>
<p><strong>创建Pipeline</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pPipeline.reset(CreatePipeline(Params));</span><br><span class="line">sts = pPipeline-&gt;Init(&amp;Params);</span><br><span class="line"><span class="comment">// print current kind of pipeline info</span></span><br><span class="line">pPipeline-&gt;PrintInfo();</span><br></pre></td></tr></table></figure></p>
<p><strong>摄像头操作</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// using yuv file as input generally,</span></span><br><span class="line">pPipeline-&gt;CaptureStartV4L2Pipeline();</span><br><span class="line">pPipeline-&gt;CaptureStopV4L2Pipeline();</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>if camera is wanted, macro ENABLE_V4L2_SUPPORT should be added to project</p>
</blockquote>
<p><strong>编码过程</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sts = pPipeline-&gt;Run();</span><br><span class="line"><span class="keyword">if</span>(sts  == MX_ERR_DEVICE_LOST || sts == MFX_ERR_DEVICE_FAILED)&#123;</span><br><span class="line">    sts = pPipeline-&gt;ResetDevice();</span><br><span class="line">    sts = pPipeline-&gt;ResetMFXComponents(&amp;Params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>销毁逻辑</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pPipeline-&gt;Close();</span><br></pre></td></tr></table></figure></p>
<h2 id="传参解析"><a href="#传参解析" class="headerlink" title="传参解析"></a>传参解析</h2><p>外部传递参数存在可选与必选参数</p>
<h4 id="必选参数"><a href="#必选参数" class="headerlink" title="必选参数"></a>必选参数</h4><div class="table-container">
<table>
<thead>
<tr>
<th>编码标准</th>
<th>输入文件</th>
<th>输出文件</th>
<th>宽</th>
<th>高</th>
</tr>
</thead>
<tbody>
<tr>
<td>h264/h265/jepg</td>
<td>-i xxx.yuv</td>
<td>-o xxx.bitstream</td>
<td>-w xxx</td>
<td>-h xxx</td>
</tr>
</tbody>
</table>
</div>
<p><code>e.g. sample_encode.exe h264 -i input.yuv -o output.h264 –w 720 –h 480</code></p>
<h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><div class="table-container">
<table>
<thead>
<tr>
<th>编码实现</th>
<th>编码格式</th>
<th>码控方式</th>
<th>会议模式</th>
</tr>
</thead>
<tbody>
<tr>
<td>-sw/-hw</td>
<td>-yuy2/-nv12/-rgb4</td>
<td>-vbr/-cbr/-qvbr/-avbr/-cqp</td>
<td>-vcm</td>
</tr>
<tr>
<td>I帧间隔</td>
<td>参考帧数</td>
<td>HEVC P帧参考帧数</td>
<td>svc 设置</td>
</tr>
<tr>
<td>-idr_internal</td>
<td>-x numRef</td>
<td>-num_active_P numRef</td>
<td>-AvcTemporalLayers “1 2 4 0 0 0 0 0”</td>
</tr>
<tr>
<td>slice 数量</td>
<td>GOP size</td>
<td>B帧</td>
<td>其他常用</td>
</tr>
<tr>
<td>-num_slice</td>
<td>-g size</td>
<td>-bref/-nobref(default)</td>
<td>-f/-b/-u/-q</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>HEVC中参考帧数与svc设置是互斥的，直接会导致编码器初始化失败.参数设置详见readme-encode_windows.pdf</p>
</blockquote>
<h4 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h4><p>默认设置使用硬编，无camera，参考帧数量为0，I420格式，而后通过匹配外部传入参数对pParams进行赋值,e.g.<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">0</span> == msdk_strcmp(strInput[i],MSDK_STRING(<span class="string">"-sw"</span>))&#123;</span><br><span class="line">    pParams-&gt;bUseHWLib = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>外部传入的所有的参数均通过此方式对默认值进行覆盖。</p>
<h2 id="Pipeline创建与初始化"><a href="#Pipeline创建与初始化" class="headerlink" title="Pipeline创建与初始化"></a>Pipeline创建与初始化</h2><p>pipeline创建时需要选择哪一种pipeline结构并进行初始化，初始化过程包含编码器的选择与其初始化等</p>
<h4 id="pipeline-reset"><a href="#pipeline-reset" class="headerlink" title="pipeline reset"></a>pipeline reset</h4><p>mediaSDK提供了三种pipeline模式</p>
<ul>
<li>CRegionEncodingPipeline : 区域编码模式，不支持硬编</li>
<li>CUserPipeline：自定义编码pipeline，可设入插件，进行图像处理，demo给出的为旋转图像能力</li>
<li>CEncodingPipeline：普通编码模式</li>
</ul>
<h4 id="pipeline-init"><a href="#pipeline-init" class="headerlink" title="pipeline init"></a>pipeline init</h4><p><strong>依据参数与限制条件，选择最合适的硬件/软件实现</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mfxInitParamlWrap initPar;</span><br><span class="line">initPar.Version.Major = <span class="number">1</span>;</span><br><span class="line">initPar.Version.Minor = <span class="number">0</span>;</span><br><span class="line">initPar.GPUCopy = nParams-&gt;gpuCopy;</span><br><span class="line">mfxStatus sts = GetImpl(*pParams,initPar.Implementation);</span><br></pre></td></tr></table></figure></p>
<p><strong>使用获取到的编码器去初始化mfxsession</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sts = m_mfxSession.InitEx(initPar);</span><br></pre></td></tr></table></figure></p>
<p><strong>获取系统版本，检验特性支持的api版本，满足时加载编码器</strong></p>
<ul>
<li>如果有自定义的编码器，则加载自定义的</li>
<li>如果没有指定编码器的path或者guid<ul>
<li>检查mediasdk当前版本是否默认含有上述选择出的编解码器，有则加载</li>
<li>如果mediasdk无该默认编解码器，则判断不支持</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mfxVersion version;</span><br><span class="line">sts = MFXQueryVersion(m_mfxSession,&amp;version);</span><br><span class="line"></span><br><span class="line"><span class="comment">// do some check by version</span></span><br><span class="line"><span class="keyword">if</span> (pParams-&gt;pluginParams.type == MFX_PLUGINLOAD_TYPE_FILE &amp;&amp; msdk_strnlen(pParams-&gt;pluginParams.strPluginPath, <span class="keyword">sizeof</span>(pParams-&gt;pluginParams.strPluginPath)))&#123;</span><br><span class="line">    m_pUserModule.reset(<span class="keyword">new</span> MFXVideoUSER(m_mfxSession));</span><br><span class="line">    m_pPlugin.reset(LoadPlugin(MFX_PLUGINTYPE_VIDEO_ENCODE, m_mfxSession, pParams-&gt;pluginParams.pluginGuid, <span class="number">1</span>, pParams-&gt;pluginParams.strPluginPath, (mfxU32)msdk_strnlen(pParams-&gt;pluginParams.strPluginPath, <span class="keyword">sizeof</span>(pParams-&gt;pluginParams.strPluginPath))));</span><br><span class="line">    <span class="keyword">if</span> (m_pPlugin.get() == <span class="literal">NULL</span>) sts = MFX_ERR_UNSUPPORTED;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">bool</span> isDefaultPlugin = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (AreGuidsEqual(pParams-&gt;pluginParams.pluginGuid, MSDK_PLUGINGUID_NULL)) &#123;</span><br><span class="line">        mfxIMPL impl = pParams-&gt;bUseHWLib ? MFX_IMPL_HARDWARE : MFX_IMPL_SOFTWARE;</span><br><span class="line">        pParams-&gt;pluginParams.pluginGuid = msdkGetPluginUID(impl, MSDK_VENCODE, pParams-&gt;CodecId);</span><br><span class="line">        isDefaultPlugin = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!AreGuidsEqual(pParams-&gt;pluginParams.pluginGuid, MSDK_PLUGINGUID_NULL)) &#123;</span><br><span class="line">        m_pPlugin.reset(LoadPlugin(MFX_PLUGINTYPE_VIDEO_ENCODE, m_mfxSession, pParams-&gt;pluginParams.pluginGuid, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (m_pPlugin.get() == <span class="literal">NULL</span>) sts = MFX_ERR_UNSUPPORTED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>创建编码器与初始化</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">m_pmfxENC = <span class="keyword">new</span> MFXVideoENCODE(m_mfxSession); <span class="comment">// create encoder</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// if no camera, file input system is inited.</span></span><br><span class="line"><span class="keyword">if</span>(!isV4L2InputEnable)&#123;</span><br><span class="line">    sts = m_FileReader.Init(pParams-&gt;InputFiles, nParams-&gt;FileInputFourCC, readerShift);</span><br><span class="line">&#125;</span><br><span class="line">sts = InitFileWriters(pParams); <span class="comment">// init output file</span></span><br><span class="line"></span><br><span class="line">sts = CretaeAlloctor();  <span class="comment">// memory init used by encoding</span></span><br><span class="line">sts = InitMfxEncParams(pParams); <span class="comment">// collect all kinds of encoder params </span></span><br><span class="line">sts = InitMfxVppParams(pParams); <span class="comment">// init vpp if needed</span></span><br><span class="line">sts = ResetMFXComponents(pParams); <span class="comment">// init task pool and set params into encoder</span></span><br><span class="line">InitV4L2Pipeline(pParams); <span class="comment">// init camera if V4L2 is opened</span></span><br></pre></td></tr></table></figure></p>
<h2 id="encode"><a href="#encode" class="headerlink" title="encode"></a>encode</h2><p>创建for循环，循环进行以下流程的处理</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">读帧：LoadNextFrame(mfxFrameSurface1)-&gt;</span><br><span class="line">编码：m_mfxENC-&gt;EncodeFrameAsync(mfxEncodeCtrl,mfxFrameSurface1,&amp;mfxBitstreamWrapper,&amp;mfxSyncPoint)-&gt;</span><br><span class="line">写流：WriteNextFrame(&amp;mfxBitstream，<span class="keyword">bool</span>)</span><br></pre></td></tr></table></figure>
<h4 id="ExtendSurface创建"><a href="#ExtendSurface创建" class="headerlink" title="ExtendSurface创建"></a>ExtendSurface创建</h4><p>extendSurface包含了编码器的数据信息与控制信息，从文件中的读取的帧会按照特定格式存放于ExtendSurface.pSurface中，ExtendSurface.pCtrl则带有帧信息，有一定的控制作用，例如编I帧等<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ExtendSurface</span> &#123;</span></span><br><span class="line">    mfxFrameSurface1 *pSurface;  <span class="comment">// 输入编码器的帧数据</span></span><br><span class="line">    mfxEncodeCtrl    *pCtrl;  <span class="comment">// 编码器控制参数</span></span><br><span class="line">    mfxSyncPoint      Syncp;  <span class="comment">//同步时机</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ExtendedSurface encSurface,preencSurface,vppSurface = &#123;&#125;;</span><br><span class="line">m_nEncSurfIdx = GetFreeSurface(m_pEncSurfaces, m_EncResponse.NumFrameActual);</span><br><span class="line">preencSurface.pSurface = vppSurface.pSurface = &amp;m_pEncSurfaces[m_nEncSurfIdx];</span><br></pre></td></tr></table></figure></p>
<h4 id="sTask创建"><a href="#sTask创建" class="headerlink" title="sTask创建"></a>sTask创建</h4><p>sTask会创建任务池，承担两项任务职能</p>
<ul>
<li>取得编码后的码流数据</li>
<li>将码流数据写入文件</li>
</ul>
<p>每次需要执行代码时，便获取当前的空任务，获取时会将当前的任务队列中的码流写文件任务执行，编码完成后会将编码后的数据填入<code>pCurrentTask.mfxBS</code>中。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sts = GetFreeTask(&amp;pCurrentTask);</span><br><span class="line">    WriteNextFrame(mfxBitstream,<span class="keyword">bool</span>) <span class="function">in <span class="title">GetFreeTask</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">EncodeOneFrame</span><span class="params">(encSurface, pCurrentTask)</span></span>;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Codec</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>h265</tag>
        <tag>h264</tag>
        <tag>svc</tag>
        <tag>video</tag>
      </tags>
  </entry>
</search>
