<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>拾趣，志人</title>
  
  <subtitle>白水日常需拾趣，书迹学知尤志人</subtitle>
  <link href="https://theme-next.js.org/atom.xml" rel="self"/>
  
  <link href="https://theme-next.js.org/"/>
  <updated>2022-04-08T13:47:18.307Z</updated>
  <id>https://theme-next.js.org/</id>
  
  <author>
    <name>awesome-wind</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SVC介绍与MSDK实现时域SVC</title>
    <link href="https://theme-next.js.org/blog/2022/04/mediasdk-svc.html"/>
    <id>https://theme-next.js.org/blog/2022/04/mediasdk-svc.html</id>
    <published>2022-04-07T08:29:53.000Z</published>
    <updated>2022-04-08T13:47:18.307Z</updated>
    
    <content type="html"><![CDATA[<p>SVC(Scaled Video Coding)最早作为H.264标准的一个扩展最初由JVT在2004年开始制定，并于2007年7月获得ITU批准，HEVC现均已支持SVC。H.264 SVC以H.264 AVC视频编解码器标准为基础，利用了AVC编解码器的各种高效算法工具，在编码产生的编码视频时间上（帧率）、空间上（分辨率）可扩展，并且是在视频质量方面可扩展的，可产生不同帧速率、分辨率或质量等级的解码视频。</p><span id="more"></span><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>SVC，可分层视频编解码，分为时域可适性（<em>Temporal Scalability</em>），空域可适性（<em>spatial Scalability</em>）和质量可适性（<em>quality Scalability</em>），是一种能将视频流分割为多个分辨率、质量和帧率层的技术，一般存在一个基本层和一个或以上的增强层，为大多数视频会议设备所采用H264&#x2F;HEVC视频编解码标准的扩展。空间可扩展性与质量可扩展性会显著增加解码器的复杂度以及显著降低编码效率，因此并未被广泛支持，然而时域可适性却可以带来显著的编码效率提升,因此而得到广泛使用。</p><h4 id="时域可适性"><a href="#时域可适性" class="headerlink" title="时域可适性"></a>时域可适性</h4><p>对于混合编码模式，可使用运动补偿编码方式，使高层Layer参考低层Layer或者同层layer即可产生时域可适性。可根据网络与解码设备状况从高层layer依次丢帧至基本层，高层layer解码依赖于底层layer。</p><p>4层时域结构，包含I帧与B帧，为1：1：2：4结构<br><img src="/images/temporal_b_frames.jpg" alt="Temporal SVC" loading="lazy"></p><p>3层时域结构，包含I帧与B帧，为1：2：4结构<br><img src="/images/temporal_nodyadic_b_frames.jpg" alt="NonDyadic Temporal SVC" loading="lazy"></p><p>4层IPPP低延时结构，包含I帧与P帧，为1：1；2：4结构<br><img src="/images/temporal_ippp_frames.jpg" alt="IPPP temporal SVC" loading="lazy"></p><h4 id="空域可适性"><a href="#空域可适性" class="headerlink" title="空域可适性"></a>空域可适性</h4><p>空域可扩展性的实现基于多层layer编码方式，每层对应各自的分辨率，一般低层layer分辨率较低，每帧参考于同层帧或者其依赖标识层帧（低层layer）。每层均会采用帧内预测与帧间预测，帧内预测时，高层layer参考低层layer，并使用上采样提升分辨率，同层参考时则使用帧间预测。解码时并非是高层layer解码依赖底层layer，只会使用特定layer层，因此，可结合时域与空域可适性。<br><img src="/images/spatial_scalability.jpg" alt="spatial SVC" loading="lazy"></p><h4 id="质量可适性"><a href="#质量可适性" class="headerlink" title="质量可适性"></a>质量可适性</h4><p>质量可适性是一种特殊的空域可适性，每层layer的分辨率相同且不会采用上采样。<br><img src="/images/quality_scalability.jpg" alt="quality SVC" loading="lazy"></p><h2 id="MediaSDK-Temporal-SVC"><a href="#MediaSDK-Temporal-SVC" class="headerlink" title="MediaSDK Temporal SVC"></a>MediaSDK Temporal SVC</h2><p>MediaSDK的时域SVC设置，在mfxVideoParam参数集中加入mfxExtAvcTemporalLayers，并设置BaseLayerPid与每层的帧数分布，MediaSDK最多支持8层结构。<code>typedef mfxExtAvcTemporalLayers mfxExtHEVCTemporalLayers</code>表明下述时域SVC设置同样适用与HEVC。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> MfxVideoParamsWrapper = ExtBufHolder&lt;mfxVideoParam&gt;;</span><br><span class="line">MfxVideoParamsWrapper m_mfxEncParams;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> avcTemporalLayers = m_mfxEncParams.<span class="built_in">AddExtBuffer</span>&lt;mfxExtAvcTemporalLayers&gt;();</span><br><span class="line"></span><br><span class="line">avcTemporalLayers-&gt;BaseLayerPID = <span class="number">0</span>;  <span class="comment">//base layer 优先级</span></span><br><span class="line">std::vector&lt;mfxU16&gt; layers&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;; <span class="comment">// 分层结构，1-3层帧数比为1：1：2</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">    avcTemporalLayers-&gt;Layer[i].Scale = layers[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><span class="exturl" data-url="aHR0cDovL2lwLmhoaS5kZS9pbWFnZWNvbV9HMS9hc3NldHMvcGRmcy9PdmVydmlld19TVkNfSUVFRTA3LnBkZg==">http://ip.hhi.de/imagecom_G1/assets/pdfs/Overview_SVC_IEEE07.pdf<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;SVC(Scaled Video Coding)最早作为H.264标准的一个扩展最初由JVT在2004年开始制定，并于2007年7月获得ITU批准，HEVC现均已支持SVC。H.264 SVC以H.264 AVC视频编解码器标准为基础，利用了AVC编解码器的各种高效算法工具，在编码产生的编码视频时间上（帧率）、空间上（分辨率）可扩展，并且是在视频质量方面可扩展的，可产生不同帧速率、分辨率或质量等级的解码视频。&lt;/p&gt;</summary>
    
    
    
    <category term="H264" scheme="https://theme-next.js.org/categories/H264/"/>
    
    <category term="HEVC" scheme="https://theme-next.js.org/categories/H264/HEVC/"/>
    
    
    <category term="MediaSDK" scheme="https://theme-next.js.org/tags/MediaSDK/"/>
    
    <category term="Encoder" scheme="https://theme-next.js.org/tags/Encoder/"/>
    
  </entry>
  
  <entry>
    <title>MediaSDK编码</title>
    <link href="https://theme-next.js.org/blog/2022/03/mediasdk-encoder.html"/>
    <id>https://theme-next.js.org/blog/2022/03/mediasdk-encoder.html</id>
    <published>2022-03-29T07:10:28.000Z</published>
    <updated>2022-04-08T13:47:13.197Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前置条件：下载并安装好<span class="exturl" data-url="aHR0cHM6Ly93d3cuaW50ZWwuY29tL2NvbnRlbnQvd3d3L3VzL2VuL2RldmVsb3Blci90b29scy9tZWRpYS1zZGsvY2hvb3NlLWRvd25sb2FkLWNsaWVudC5odG1s">media sdk工程<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>使用visual studio打开默认的工程sample_encode.sln后，在vs中可以看到整个工程的代码结构。程序的启动点位于sample_encode.cpp中的main函数，包含了编码器创建，编码过程以及销毁流程。</p><span id="more"></span><h2 id="main函数结构"><a href="#main函数结构" class="headerlink" title="main函数结构"></a>main函数结构</h2><p>查看代码逻辑，整体代码流程可分为以下五个部分</p><p><strong>解析外部传参</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Parsing Input Stream working with presets</span></span><br><span class="line">sts = <span class="built_in">ParseInputString</span>(argv, (mfxU8)argc, &amp;Params);</span><br><span class="line"><span class="built_in">ModifyParamUsingPresets</span>(Params);</span><br></pre></td></tr></table></figure><p><strong>创建Pipeline</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pPipeline.<span class="built_in">reset</span>(<span class="built_in">CreatePipeline</span>(Params));</span><br><span class="line">sts = pPipeline-&gt;<span class="built_in">Init</span>(&amp;Params);</span><br><span class="line"><span class="comment">// print current kind of pipeline info</span></span><br><span class="line">pPipeline-&gt;<span class="built_in">PrintInfo</span>(); </span><br></pre></td></tr></table></figure><p><strong>摄像头操作</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// using yuv file as input generally,</span></span><br><span class="line">pPipeline-&gt;<span class="built_in">CaptureStartV4L2Pipeline</span>();</span><br><span class="line">pPipeline-&gt;<span class="built_in">CaptureStopV4L2Pipeline</span>();</span><br></pre></td></tr></table></figure><blockquote><p>if camera is wanted, macro ENABLE_V4L2_SUPPORT should be added to project</p></blockquote><p><strong>编码过程</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sts = pPipeline-&gt;<span class="built_in">Run</span>();</span><br><span class="line"><span class="keyword">if</span>(sts  == MX_ERR_DEVICE_LOST || sts == MFX_ERR_DEVICE_FAILED)&#123;</span><br><span class="line">    sts = pPipeline-&gt;<span class="built_in">ResetDevice</span>();</span><br><span class="line">    sts = pPipeline-&gt;<span class="built_in">ResetMFXComponents</span>(&amp;Params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>销毁逻辑</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pPipeline-&gt;<span class="built_in">Close</span>();</span><br></pre></td></tr></table></figure><h2 id="传参解析"><a href="#传参解析" class="headerlink" title="传参解析"></a>传参解析</h2><p>外部传递参数存在可选与必选参数，</p><h4 id="必选参数"><a href="#必选参数" class="headerlink" title="必选参数"></a>必选参数</h4><table><thead><tr><th>编码标准</th><th>输入文件</th><th>输出文件</th><th>宽</th><th>高</th></tr></thead><tbody><tr><td>h264&#x2F;h265&#x2F;jepg</td><td>-i xxx.yuv</td><td>-o xxx.bitstream</td><td>-w xxx</td><td>-h xxx</td></tr></tbody></table><p><code>e.g. sample_encode.exe h264 -i input.yuv -o output.h264 –w 720 –h 480</code></p><h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><table><thead><tr><th>编码实现</th><th>编码格式</th><th>码控方式</th><th>会议模式</th></tr></thead><tbody><tr><td>-sw&#x2F;-hw</td><td>-yuy2&#x2F;-nv12&#x2F;-rgb4</td><td>-vbr&#x2F;-cbr&#x2F;-qvbr&#x2F;-avbr&#x2F;-cqp</td><td>-vcm</td></tr><tr><td>I帧间隔</td><td>参考帧数</td><td>HEVC P帧参考帧数</td><td>svc 设置</td></tr><tr><td>-idr_internal</td><td>-x numRef</td><td>-num_active_P numRef</td><td>-AvcTemporalLayers &quot;1 2 4 0 0 0 0 0&quot;</td></tr><tr><td>slice 数量</td><td>GOP size</td><td>B帧</td><td>其他常用</td></tr><tr><td>-num_slice</td><td>-g size</td><td>-bref&#x2F;-nobref(default)</td><td>-f&#x2F;-b&#x2F;-u&#x2F;-q</td></tr></tbody></table><blockquote><p>HEVC中参考帧数与svc设置是互斥的，直接会导致编码器初始化失败.参数设置详见readme-encode_windows.pdf</p></blockquote><h4 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h4><p>默认设置使用硬编，无camera，参考帧数量为0，I420格式，而后通过匹配外部传入参数对pParams进行赋值,e.g.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">msdk_strcmp</span>(strInput[i],<span class="built_in">MSDK_STRING</span>(<span class="string">&quot;-sw&quot;</span>))&#123;</span><br><span class="line">    pParams-&gt;bUseHWLib = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="创建pipeline"><a href="#创建pipeline" class="headerlink" title="创建pipeline"></a>创建pipeline</h1><h4 id="pipeline-reset"><a href="#pipeline-reset" class="headerlink" title="pipeline reset"></a>pipeline reset</h4><p>mediaSDK提供了三种pipeline模式</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CRegionEncodingPipeline : 区域编码模式，不支持硬编</span><br><span class="line">CUserPipeline：自定义编码pipeline，可设入插件，进行图像处理，demo给出的为旋转图像能力</span><br><span class="line">CEncodingPipeline：普通编码模式</span><br></pre></td></tr></table></figure><h4 id="pipeline-init"><a href="#pipeline-init" class="headerlink" title="pipeline init"></a>pipeline init</h4><ol><li><p>依据参数与限制条件，选择最合适的硬件&#x2F;软件实现</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mfxInitParamlWrap initPar;</span><br><span class="line">initPar.Version.Major = <span class="number">1</span>;</span><br><span class="line">initPar.Version.Minor = <span class="number">0</span>;</span><br><span class="line">initPar.GPUCopy = nParams-&gt;gpuCopy;</span><br><span class="line">mfxStatus sts = <span class="built_in">GetImpl</span>(*pParams,initPar.Implementation);</span><br></pre></td></tr></table></figure></li><li><p>使用获取到的编码器去初始化mfxsession</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sts = m_mfxSession.<span class="built_in">InitEx</span>(initPar);</span><br></pre></td></tr></table></figure></li><li><p>获取系统版本，检验特性支持的api版本，满足时加载编码器<br>如果有自定义的编码器，则加载自定义的,若没有指定编码器的path或者guid则检查mediasdk当前版本是否默认含有上述选择出的编解码器，有则加载，否则判断为不支持</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mfxVersion version;</span><br><span class="line">sts = <span class="built_in">MFXQueryVersion</span>(m_mfxSession,&amp;version);</span><br><span class="line"></span><br><span class="line"><span class="comment">// do some check by version</span></span><br><span class="line"><span class="keyword">if</span> (pParams-&gt;pluginParams.type == MFX_PLUGINLOAD_TYPE_FILE &amp;&amp; <span class="built_in">msdk_strnlen</span>(pParams-&gt;pluginParams.strPluginPath, <span class="built_in">sizeof</span>(pParams-&gt;pluginParams.strPluginPath)))&#123;</span><br><span class="line">    m_pUserModule.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">MFXVideoUSER</span>(m_mfxSession));</span><br><span class="line">    m_pPlugin.<span class="built_in">reset</span>(<span class="built_in">LoadPlugin</span>(MFX_PLUGINTYPE_VIDEO_ENCODE, m_mfxSession, pParams-&gt;pluginParams.pluginGuid, <span class="number">1</span>, pParams-&gt;pluginParams.strPluginPath, (mfxU32)<span class="built_in">msdk_strnlen</span>(pParams-&gt;pluginParams.strPluginPath, <span class="built_in">sizeof</span>(pParams-&gt;pluginParams.strPluginPath))));</span><br><span class="line">    <span class="keyword">if</span> (m_pPlugin.<span class="built_in">get</span>() == <span class="literal">NULL</span>) sts = MFX_ERR_UNSUPPORTED;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">bool</span> isDefaultPlugin = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">AreGuidsEqual</span>(pParams-&gt;pluginParams.pluginGuid, MSDK_PLUGINGUID_NULL)) &#123;</span><br><span class="line">        mfxIMPL impl = pParams-&gt;bUseHWLib ? MFX_IMPL_HARDWARE : MFX_IMPL_SOFTWARE;</span><br><span class="line">        pParams-&gt;pluginParams.pluginGuid = <span class="built_in">msdkGetPluginUID</span>(impl, MSDK_VENCODE, pParams-&gt;CodecId);</span><br><span class="line">        isDefaultPlugin = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">AreGuidsEqual</span>(pParams-&gt;pluginParams.pluginGuid, MSDK_PLUGINGUID_NULL)) &#123;</span><br><span class="line">        m_pPlugin.<span class="built_in">reset</span>(<span class="built_in">LoadPlugin</span>(MFX_PLUGINTYPE_VIDEO_ENCODE, m_mfxSession, pParams-&gt;pluginParams.pluginGuid, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (m_pPlugin.<span class="built_in">get</span>() == <span class="literal">NULL</span>) sts = MFX_ERR_UNSUPPORTED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建编码器与初始化</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">m_pmfxENC = <span class="keyword">new</span> <span class="built_in">MFXVideoENCODE</span>(m_mfxSession); <span class="comment">// create encoder</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// if no camera, file input system is inited.</span></span><br><span class="line"><span class="keyword">if</span>(!isV4L2InputEnable)&#123;</span><br><span class="line">    sts = m_FileReader.<span class="built_in">Init</span>(pParams-&gt;InputFiles, nParams-&gt;FileInputFourCC, readerShift);</span><br><span class="line">&#125;</span><br><span class="line">sts = <span class="built_in">InitFileWriters</span>(pParams); <span class="comment">// init output file</span></span><br><span class="line"></span><br><span class="line">sts = <span class="built_in">CretaeAlloctor</span>();  <span class="comment">// memory init used by encoding</span></span><br><span class="line">sts = <span class="built_in">InitMfxEncParams</span>(pParams); <span class="comment">// collect all kinds of encoder params </span></span><br><span class="line">sts = <span class="built_in">InitMfxVppParams</span>(pParams); <span class="comment">// init vpp if needed</span></span><br><span class="line">sts = <span class="built_in">ResetMFXComponents</span>(pParams); <span class="comment">// init task pool and set params into encoder</span></span><br><span class="line"><span class="built_in">InitV4L2Pipeline</span>(pParams); <span class="comment">// init camera if V4L2 is opened</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h1 id="encode"><a href="#encode" class="headerlink" title="encode"></a>encode</h1><p>创建for循环，循环进行以下流程的处理</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">读帧：<span class="built_in">LoadNextFrame</span>(mfxFrameSurface1)</span><br><span class="line">编码：m_mfxENC-&gt;<span class="built_in">EncodeFrameAsync</span>(mfxEncodeCtrl,mfxFrameSurface1,&amp;mfxBitstreamWrapper,&amp;mfxSyncPoint)</span><br><span class="line">写流：<span class="built_in">WriteNextFrame</span>(&amp;mfxBitstream，<span class="type">bool</span>)</span><br></pre></td></tr></table></figure><h4 id="ExtendSurface创建"><a href="#ExtendSurface创建" class="headerlink" title="ExtendSurface创建"></a>ExtendSurface创建</h4><p>extendSurface包含了编码器的数据信息与控制信息，从文件中的读取的帧会按照特定格式存放于ExtendSurface.pSurface中，ExtendSurface.pCtrl则带有帧信息，有一定的控制作用，例如编I帧等</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ExtendSurface</span> &#123;</span><br><span class="line">    mfxFrameSurface1 *pSurface;  <span class="comment">// 输入编码器的帧数据</span></span><br><span class="line">    mfxEncodeCtrl    *pCtrl;  <span class="comment">// 编码器控制参数</span></span><br><span class="line">    mfxSyncPoint      Syncp;  <span class="comment">//同步时机</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ExtendedSurface encSurface,preencSurface,vppSurface = &#123;&#125;;</span><br><span class="line">m_nEncSurfIdx = <span class="built_in">GetFreeSurface</span>(m_pEncSurfaces, m_EncResponse.NumFrameActual);</span><br><span class="line">preencSurface.pSurface = vppSurface.pSurface = &amp;m_pEncSurfaces[m_nEncSurfIdx];</span><br></pre></td></tr></table></figure><h4 id="sTask创建"><a href="#sTask创建" class="headerlink" title="sTask创建"></a>sTask创建</h4><p>sTask会创建任务池，承担两项任务职能</p><ul><li>取得编码后的码流数据</li><li>将码流数据写入文件</li></ul><p>每次需要执行代码时，便获取当前的空任务，获取时会将当前的任务队列中的码流写文件任务执行，编码完成后会将编码后的数据填入<code>pCurrentTask.mfxBS</code>中。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sts = <span class="built_in">GetFreeTask</span>(&amp;pCurrentTask);</span><br><span class="line">    <span class="built_in">WriteNextFrame</span>(mfxBitstream,<span class="type">bool</span>) <span class="function">in <span class="title">GetFreeTask</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">EncodeOneFrame</span><span class="params">(encSurface, pCurrentTask)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;前置条件：下载并安装好&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly93d3cuaW50ZWwuY29tL2NvbnRlbnQvd3d3L3VzL2VuL2RldmVsb3Blci90b29scy9tZWRpYS1zZGsvY2hvb3NlLWRvd25sb2FkLWNsaWVudC5odG1s&quot;&gt;media sdk工程&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用visual studio打开默认的工程sample_encode.sln后，在vs中可以看到整个工程的代码结构。程序的启动点位于sample_encode.cpp中的main函数，包含了编码器创建，编码过程以及销毁流程。&lt;/p&gt;</summary>
    
    
    
    <category term="Codec" scheme="https://theme-next.js.org/categories/Codec/"/>
    
    
    <category term="MediaSDK" scheme="https://theme-next.js.org/tags/MediaSDK/"/>
    
    <category term="QSV" scheme="https://theme-next.js.org/tags/QSV/"/>
    
    <category term="Encoder" scheme="https://theme-next.js.org/tags/Encoder/"/>
    
  </entry>
  
</feed>
